var env = process.env.NODE_ENV = process.env.NODE_ENV || 'development',
  config = require('./config'),
  // Custom winston logger
  logger = require('./log'),
  express = require('express'),
  params = require('express-params'),
  redisClient = require('./redis'),
  redisStore = require('connect-redis')(express),
  flash = require('connect-flash'),
  // Express HTTP access and error logging
  // Default winston logger for express-winston to use
  winston = require('winston'),
  expressWinston = require('express-winston');

module.exports = function (app, passport) {

  params.extend(app);

  app.set('port', config.get('port'));
  app.set('views', [config.get('root'), 'www', 'views'].join('/'));
  app.set('view engine', 'ejs');

  // HTML using ejs is used with server auth protected angularjs templates
  // Eg. Only logged in uses can load the create template
  app.engine('html', require('ejs').renderFile);

  app.disable('x-powered-by');

  // Enable response compression (utilize bandwidth)
  app.use(express.compress({
    filter: function(req, res) {
      return (/json|text|javascript|css/).test(res.getHeader('Content-Type'));
    },
    // Levels are specified in a range of 0 to 9, where-as 0 is
    // no compression and 9 is best compression, but slowest
    level: 9
  }));

  app.use(express.json());
  app.use(express.urlencoded());

  app.use(express.methodOverride());

  app.use(express.cookieParser());

  // Session storage
  app.use(express.session({
    key: config.get('cookieKey'),
    secret: config.get('cookieSecret'),
    cookie: {
      domain: config.get('app').cookieDomain,
      expires: new Date(config.get('cookieExpire'))
    },
    store: new redisStore({
      secret: config.get('redisSessionSecret'),
      client: redisClient
    })
  }));

  // connect-flash required by passportjs for flash messages
  app.use(flash());

  // use passport session
  app.use(passport.initialize());
  app.use(passport.session());

  app.use(express.csrf());

  // Angular’s $http library reads the token from the XSRF-TOKEN cookie.
  // We therefore have to set this cookie and send it to the client.
  // Setting a cookie in Express is done via the res.cookie('name', 'value') function.
  // The name is obviously XSRF-TOKEN. The value is read from the user’s session.
  // The key req.session._csrf is automatically generated by the csrf middleware.
  app.use(function (req, res, next) {
    res.cookie('XSRF-TOKEN', req.csrfToken());
    next();
  });

  // Logging

  // HTTP log
  // express-winston logger BEFORE the router.
  app.use(expressWinston.logger({
    transports: [
      new (winston.transports.File)({
        filename: config.get('root') + '/log/' + env + '_access.log',
        maxsize: config.get('logMaxFileSize'),
        maxfiles: config.get('logMaxFiles')
      })
    ]
  }));

  app.use(app.router);

  // static files are handled by NGINX in production
  app.use(express.static([config.get('root'), 'app'].join('/')));

  // Error log
  // express-winston errorLogger AFTER the router.
  app.use(expressWinston.errorLogger({
    transports: [
      new (winston.transports.File)({
        filename: config.get('root') + '/log/' + env + '_error.log',
        maxsize: config.get('logMaxFileSize'),
        maxfiles: config.get('logMaxFiles')
      })
    ]
  }));

  // Server error handling
  app.use(function (err, req, res, next) {

    logger.error(err.stack);

    // If 403 error send JSON response
    if (err.status === +403) {

      logger.error('403: ' + req.originalUrl);
      res.jsonp(403, {error: 'Forbidden'});
    }
    else {

      // 500 error repsonse

      logger.error('500: ' + req.originalUrl);

      // Error message to display
      var errorMsg;

      if ('production' === app.get('env')) {
        errorMsg = 'We\'re sorry, but something went wrong. We\'ve been notified about this issue and we\'ll follow up on this right away.';
      }
      else {
        errorMsg = err.stack;
      }

      res.status(500).render('500.html', { error: errorMsg });

      // Fix JSHint's warning of next not being used by defining it
      next = next;

      return;
    }

  });

  // Assume 404 since no middleware responded
  app.use(function (req, res) {

    logger.error('404: ' + req.originalUrl);

    // AngularJS handle 404 page or 301 permanent redirect (better for SEO?)

    // 404 response
    // res.redirect('/#' + req.originalUrl);

    // 301 response
    res.writeHead(301, {'Location': '/#' + req.originalUrl});
    res.end();

  });

};
